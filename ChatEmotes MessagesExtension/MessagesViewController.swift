//
//  MessagesViewController.swift
//  ChatEmotes MessagesExtension
//
//  Created by Chris Rudel on 2/22/23.
//

import UIKit
import Messages
import CoreData

//  Would like to keep the API URL and Key private, storing them in env variables
let url = URL(string:  ProcessInfo.processInfo.environment["API_URL"]! + ProcessInfo.processInfo.environment["API_KEY"]!)
var topEmotes = [Emote]()

class MessagesViewController: MSMessagesAppViewController {
    lazy var context = persistentContainer.viewContext
    
    @IBOutlet weak var collectionView: UICollectionView!
    
    @IBOutlet weak var textField: UITextField!
    
    @IBAction func textFieldBegin(_ sender: UITextField) {
        print("begin")
        if( self.presentationStyle == .compact){
            self.requestPresentationStyle(.expanded)
            //  Need to wait for presentation style to change to expanded
            //  Don't know if there is a better wait to await for animation to end
            DispatchQueue.main.asyncAfter(deadline: .now() + 0.5, execute: {
                self.textField.becomeFirstResponder()
            })
        }
    }
    @IBAction func searchSent(_ sender: UITextField) {
        print("Text: \(textField.text ?? "")")
        textField.resignFirstResponder()
        print(topEmotes.count)
        topEmotes = findEmotes(searchString: textField.text ?? "")
        DispatchQueue.main.async {
            self.collectionView.reloadData()
        }
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        
        let layout = UICollectionViewFlowLayout()
        layout.itemSize = CGSize(width: 30, height: 30)
        collectionView.collectionViewLayout = layout
        
        
        collectionView.register(MyCollectionViewCell.nib(), forCellWithReuseIdentifier: MyCollectionViewCell.identifier)
        
        collectionView.delegate = self
        collectionView.dataSource = self
        Task.init{
            let emotes = await getEmotes(from: url!)
            topEmotes = emotes
            DispatchQueue.main.async {
                self.collectionView.reloadData()
            }
        }
    }
    
    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        
        // Use this method to configure the extension and restore previously stored state.
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dismisses the extension, changes to a different
        // conversation or quits Messages.
        
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        
        // Use this method to trigger UI updates in response to the message.
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
    
        // Use this method to prepare for the change in presentation style.
    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
    
        // Use this method to finalize any behaviors associated with the change in presentation style.
    }
    
    // custom functions:
    
    //Call API for bulk emotes:
    private func getEmotes(from url:URL) async -> [Emote]{
        //todo: Check if data exists from past 24 hours.
        //      yes -> do not call url and populate with existing data
        //      no ->  call url and populate with data from url
        //      https://youtu.be/gWurhFqTsPU
        
        do{
            let fet = try context.fetch(APIData.fetchRequest())
            if(fet.count > 0){
                let currentDateTime = Date()
                print("Date difference: \(currentDateTime.timeIntervalSince(fet[0].date!)), num needed: \(24*60*60)")
                print("length of fetch: \(fet.count)")
                //print("printing fetch:")
                //print(fet[0].data ?? "")
                if(currentDateTime.timeIntervalSince(fet[0].date!) < 24 * 60 * 60){
                    print("Data is relatively fresh")
                    let dataStr = fet[0].data
                    let res = try JSONDecoder().decode([Emote].self, from: (dataStr?.data(using: .utf8))!)
                    return res
                }else{
                    print("Data is not fresh")
                    context.delete(fet[0])
                    saveContext()
                }
            }
            
        }catch{
            print("Error retrieving data: \(error)")
        }
        
        do{
            print("calling api")
            let (data, _) = try await URLSession.shared.data(from: url)
            let decodedData = String(decoding: data, as: UTF8.self)
            let res = try JSONDecoder().decode([Emote].self, from: data)
            
            // Save the api data to Core Data. APIData takes in data as String and date as Date
            let newData = APIData(context: self.context)
            newData.data = decodedData
            newData.date = Date()
            
            saveContext()
            
            return res
        }catch{
            return []
        }
    }
    
    private func saveContext() {
        if context.hasChanges{
            do{
                try context.save()
            }catch{
                print("an error occured while saving: \(error)")
            }
        }
    }
    
    
    lazy var persistentContainer: NSPersistentContainer = {
        let container = NSPersistentContainer(name: "APIData")
        container.loadPersistentStores(completionHandler: { (storeDescription, error ) in
            if let error = error as NSError?{
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        return container
    }()
    
    private func findEmotes(searchString: String) -> [Emote] {
        if(searchString == ""){
            print("blank search string")
        }
        
        let sortedEmotes = topEmotes.sorted { (p1, p2) -> Bool in
            let distance1 = levenshteinDistance(s1: p1.name.lowercased(), s2: searchString.lowercased())
            let distance2 = levenshteinDistance(s1: p2.name.lowercased(), s2: searchString.lowercased())
            return distance1 < distance2
        }
//        for emote in sortedEmotes{
//            print(emote.name)
//        }
        
        return sortedEmotes
    }
    
    private func levenshteinDistance(s1: String, s2: String) -> Int {
        let m = s1.count
        let n = s2.count
        
        if m == 0 {
            return n
        }
        if n == 0 {
            return m
        }
        var matrix = [[Int]](repeating: [Int](repeating: 0, count: n + 1), count: m + 1)
        for i in 0...m {
            matrix[i][0] = i
        }
        for j in 0...n {
            matrix[0][j] = j
        }
        for i in 1...m {
            for j in 1...n {
                if s1[s1.index(s1.startIndex, offsetBy: i - 1)] == s2[s2.index(s2.startIndex, offsetBy: j - 1)] {
                    matrix[i][j] = matrix[i-1][j-1]
                } else {
                    matrix[i][j] = min(matrix[i-1][j], matrix[i][j-1], matrix[i-1][j-1]) + 1
                }
            }
        }
        return matrix[m][n]
    }
}

extension MessagesViewController: UICollectionViewDelegate{
    
    //func is called whenever a cell is tapped within the collectionView
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        collectionView.deselectItem(at: indexPath, animated: true)
        
        let cell = collectionView.cellForItem(at: indexPath) as? MyCollectionViewCell
        
        let image = cell?.imageView.image
        //let image = bigImage?.resize(to: CGSize(width: 128, height: 128))
        
        //print("row: \(indexPath.row), section: \(indexPath.section), collectionview: \(String(describing: cell)), image: \(String(describing: image))")
        
        guard let conversation = activeConversation else{
            print("conversation failed")
            return
        }
        let tempDir = NSTemporaryDirectory()
        let tempURL = NSURL(fileURLWithPath: tempDir).appendingPathComponent("sticker.png")!
        guard let stickerData = image?.pngData(), (try? stickerData.write(to: tempURL, options: [.atomic])) != nil else{
            print("Failed to create temporary sticker file")
            return
        }
        do {
            let sticker = try MSSticker(contentsOfFileURL: tempURL, localizedDescription: "")
            conversation.insert(sticker) {error in
                if let error = error{
                    print("error sending message: \(String(describing: error))")
                }
            }
            self.requestPresentationStyle(.compact)
            return
        } catch {
            print("Failed to create MSSticker from temporary file: \(error)")
            return
        }
        
    }
}

extension MessagesViewController: UICollectionViewDataSource{
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        if(topEmotes.isEmpty){
            return 0
        } else {return 65}
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        if(topEmotes.isEmpty){
            return UICollectionViewCell()
        }
        var cell =  UICollectionViewCell()
        let link = topEmotes[indexPath.row].urls.two ?? topEmotes[indexPath.row].urls.one
        
        if let imageCell = collectionView.dequeueReusableCell(withReuseIdentifier: MyCollectionViewCell.identifier, for: indexPath) as? MyCollectionViewCell{
            
            imageCell.configure(with: link)
            cell = imageCell
        }
        
        return cell
    }
}


extension MessagesViewController: UICollectionViewDelegateFlowLayout{
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {

        let numColumns: CGFloat = 5
        let width = collectionView.frame.size.width
        let insets: CGFloat = 5
        let spacing: CGFloat = 5
        return CGSize(width: (width / numColumns) - (insets + spacing), height: (width / numColumns) - (insets + spacing))
    }
}

//extension UIImage {
//    func resize(to newSize: CGSize) -> UIImage? {
//            UIGraphicsBeginImageContextWithOptions(newSize, false, 0.0)
//            defer { UIGraphicsEndImageContext() }
//            self.draw(in: CGRect(origin: CGPoint.zero, size: newSize))
//            return UIGraphicsGetImageFromCurrentImageContext()
//        }
//}



struct Emote: Codable{
    let name: String
    let id: Int
    let usage_count: Int
    let urls: URLS
}
struct URLS: Codable{
    let one: String
    let two: String?
    let four: String?

    enum CodingKeys: String, CodingKey{
        case one = "1"
        case two = "2"
        case four = "4"
    }
}



/*
 [
     {
         "name": "OMEGALUL",
         "id": 128054,
         "usage_count": 206308,
         "urls": {
             "1": "https://cdn.frankerfacez.com/emote/128054/1",
             "2": "https://cdn.frankerfacez.com/emote/128054/2",
             "4": "https://cdn.frankerfacez.com/emote/128054/4"
         }
     },
     {
         "name": "Pog",
         "id": 210748,
         "usage_count": 189280,
         "urls": {
             "1": "https://cdn.frankerfacez.com/emote/210748/1",
             "2": "https://cdn.frankerfacez.com/emote/210748/2",
             "4": "https://cdn.frankerfacez.com/emote/210748/4"
         }
    },
 ...
 ]
 */
