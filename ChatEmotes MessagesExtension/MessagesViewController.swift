//
//  MessagesViewController.swift
//  ChatEmotes MessagesExtension
//
//  Created by Chris Rudel on 2/22/23.
//

import UIKit
import Messages

let url = URL(string:  "https://api.frankerfacez.com/v1/emotes?sort=count-desc&per_page=66")
var topEmotes = [Emoticons]()

class MessagesViewController: MSMessagesAppViewController {
    
    
    @IBAction func pressMeBtn(_ sender: Any) {
        
        let layout = MSMessageTemplateLayout()
        layout.image = UIImage(named: "KEKW.png")
        print("assigned image")
        
        let message = MSMessage()
        message.layout = layout
        print("assigned message")
        
//        activeConversation?.insert(message) {error in
//                print(error.self as Any)
//            }
        print("end of function")
        
    }
    
    
    @IBOutlet weak var collectionView: UICollectionView!
    
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        
        let layout = UICollectionViewFlowLayout()
        layout.itemSize = CGSize(width: 30, height: 30)
        collectionView.collectionViewLayout = layout
        
        
        collectionView.register(MyCollectionViewCell.nib(), forCellWithReuseIdentifier: MyCollectionViewCell.identifier)
        
        collectionView.delegate = self
        collectionView.dataSource = self
        Task.init{
            let emotes = await getEmotes(from: url!)
            topEmotes = emotes
            DispatchQueue.main.async {
                self.collectionView.reloadData()
            }
        }
    }
    
    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        
        // Use this method to configure the extension and restore previously stored state.
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dismisses the extension, changes to a different
        // conversation or quits Messages.
        
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }
   
    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device.
        
        // Use this method to trigger UI updates in response to the message.
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
    
        // Use this method to prepare for the change in presentation style.
    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
    
        // Use this method to finalize any behaviors associated with the change in presentation style.
    }
    
    // custom functions:
    
    //Call API for bulk emotes:
    private func getEmotes(from url:URL) async -> [Emoticons]{
        do{
            let (data, _) = try await URLSession.shared.data(from: url)
            let res = try JSONDecoder().decode(Response.self, from: data)
            let emotes = res.emoticons
            return emotes
        }catch{
            return []
        }
    }
    
//    private func getImage(from url:URL) async -> UIImage{
//        do{
//            let session = URLSession(configuration: .default)
//            let task = try await session.dataTask(with: url)
//            print(task)
//            return UIImage()
//        }catch{
//            return UIImage()
//        }
//    }

}

extension MessagesViewController: UICollectionViewDelegate{
    
    //func is called whenever a cell is tapped within the collectionView
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        collectionView.deselectItem(at: indexPath, animated: true)
        
        print("You tapped me")
    }
}

extension MessagesViewController: UICollectionViewDataSource{
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        if(topEmotes.isEmpty){
            return 0
        } else {return 66}
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        if(topEmotes.isEmpty){
            return UICollectionViewCell()
        }
        var cell =  UICollectionViewCell()
        var link = topEmotes[indexPath.row].urls.one
        link = String(link.dropFirst(2))
        //print(link)
        link = "https://" + link
        
        if let imageCell = collectionView.dequeueReusableCell(withReuseIdentifier: MyCollectionViewCell.identifier, for: indexPath) as? MyCollectionViewCell{
            
            imageCell.configure(with: link)
            cell = imageCell
        }
        
        return cell
    }
}


extension MessagesViewController: UICollectionViewDelegateFlowLayout{
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {

        let numColumns: CGFloat = 5
        let width = collectionView.frame.size.width
        let insets: CGFloat = 15
        let spacing: CGFloat = 15
        return CGSize(width: (width / numColumns) - (insets + spacing), height: (width / numColumns) - (insets + spacing))
    }
}



struct Response: Codable {
    let emoticons: [Emoticons]
}
struct Emoticons: Codable{
    let id: Int
    let name: String
    let urls: URLS
    let usage_count: Int
}
struct URLS: Codable{
    let one: String
    let two: String?
    let four: String?
    
    enum CodingKeys: String, CodingKey{
        case one = "1"
        case two = "2"
        case four = "4"
    }
}



/*
 {
   "_pages": 6178,
   "_total": 308872,
   "emoticons": [
     {
       "id": 128054,
       "name": "OMEGALUL",
       "height": 32,
       "width": 31,
       "public": true,
       "hidden": false,
       "modifier": false,
       "offset": null,
       "margins": null,
       "css": null,
       "owner": { "_id": 40215, "name": "dourgent", "display_name": "DourGent" },
       "urls": {
         "1": "//cdn.frankerfacez.com/emote/128054/1",
         "2": "//cdn.frankerfacez.com/emote/128054/2",
         "4": "//cdn.frankerfacez.com/emote/128054/4"
       },
       "status": 1,
       "usage_count": 205425,
       "created_at": "2016-09-10T21:18:46.045Z",
       "last_updated": "2016-09-11T01:11:24.046Z"
     }, ...
    ]
  }
 */
